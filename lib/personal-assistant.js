// Generated by CoffeeScript 1.6.1
(function() {
  var MAX_CHUNK_SIZE, PAFactory, Pusher, Q, async, winston, _,
    __slice = [].slice;

  async = require('async');

  Q = require('q');

  winston = require('winston');

  Pusher = require('pusher');

  _ = require('underscore');

  MAX_CHUNK_SIZE = 50;

  PAFactory = function(options) {
    var PAConstructor, PersonalAssistant, globalMiddleware, handleUpdates, heartbeatInterval, maxChunkSize, pas, pusher, redisClient, redisPub, redisSub, rootPa;
    globalMiddleware = [];
    pas = {};
    rootPa = null;
    heartbeatInterval = options.heartbeatInterval || 60 * 60 * 1000;
    redisPub = options.redisPub;
    redisSub = options.redisSub;
    redisClient = options.redisClient;
    handleUpdates = options.handleUpdates || false;
    maxChunkSize = options.maxChunkSize || MAX_CHUNK_SIZE;
    if (handleUpdates) {
      pusher = options.pusherClient || new Pusher(options.pusher);
    }
    /**
     * API:
     * 
     * `query`       - Pass in query name and qry data. Return
     *                 the queryId and the result of the query
     * `extendQuery` - Pass in queryId and new query data. Return
     *                 the new queryId, the query result and the new
     *                 extended query
     * `maybeModifiedQuery` - pass in the queryname 
     *                 If anything has changed then we'll get a push out to 
     *                 all listeners that things have changed.
     * `setQueryUniqifier` - setup a handler to basically create the queryId
     *                  from the query.
     * `setQueryHandler` - register the function to handle a specific query name
     * `setQueryExtender` - register the function to handle extending a query
     *
     * `use`         - Add in middleware. Middleware should take the qry parameter
     *                 and a callback
     *
     * `qry` parameter
     *
     * Has the following attributes
     * - session (a session like object that gets stored alongside the query)
     * - qryName
     * - handler
     * - uniqifier
     * - version (optional version to perform the query at. Absent means whatever version)
     * - qryId (may not be present if we don't have one yet)
     * - qry
     * - result (may not be present if we dont have one yet)
     * - modified (has the query been modified this time)
     *
     * Plus middleware etc could add to this.
    */

    PersonalAssistant = (function() {

      function PersonalAssistant(namespace) {
        var channel,
          _this = this;
        if (namespace) {
          pas[namespace] = this;
        } else {
          rootPa = this;
        }
        this.namespace = namespace;
        this.queryHandlers = {};
        this.middleware = [];
        /*
            We set up the following keys in redis
            pa:query:namespace:`qryId`               - the data for the queryId - { result, qryName, qry, version }
            pa:qryIds:namespace:`qryName`            - a set of queryIds for the given queryname
            pa:latestQueryVersion                    - a key holding the latest query version (to use when
                                                       determining whether a query result should be updated)
        */

        this.qryIdKeyPref = "pa:query:";
        if (namespace) {
          this.qryIdKeyPref += namespace + ":";
        }
        this.qryNameListKeyPref = "pa:qryIds:";
        if (namespace) {
          this.qryNameListKeyPref += namespace + ":";
        }
        this.latestQueryVersionKey = "pa:latestQueryVersion";
        if (handleUpdates) {
          channel = "maybeModifiedQuery" + (namespace ? ":" + namespace : "");
          redisSub.subscribe(channel);
          redisSub.on("message", function(_channel, message) {
            if (_channel === channel) {
              return _this.maybeModifiedQueryMsgReceived(message);
            }
          });
          setInterval(this._keepSocketAlive.bind(this), heartbeatInterval);
        }
      }

      /* API BITS
      */


      PersonalAssistant.prototype.query = function(qryName, data, initialProps, callback) {
        var qry, _qry;
        if (typeof initialProps === 'function') {
          callback = initialProps;
          initialProps = null;
        }
        initialProps || (initialProps = {});
        _qry = {
          qryName: qryName,
          qry: data
        };
        qry = _.extend({}, initialProps, _qry);
        return this.runQuery(qry, function(err, qry) {
          if (err) {
            return callback(err);
          }
          return typeof callback === "function" ? callback(null, qry.qryId, qry.result) : void 0;
        });
      };

      PersonalAssistant.prototype.extendQuery = function(qryName, qryId, data, initialProps, callback) {
        var extender, promise,
          _this = this;
        if (typeof initialProps === 'function') {
          callback = initialProps;
          initialProps = null;
        }
        extender = this.getHandler('extender', qryName);
        promise = this._extendQuery(extender, qryId, data);
        promise.then(function(newQry) {
          return _this.query(qryName, newQry, initialProps, callback);
        });
        return promise.fail(function(err) {
          return callback(err);
        });
      };

      PersonalAssistant.prototype.maybeModifiedQuery = function(qryName) {
        var channel;
        channel = "maybeModifiedQuery" + (this.namespace ? ":" + this.namespace : "");
        return redisClient.incr(this.latestQueryVersionKey, function(err, version) {
          if (err) {
            return winston.log(err);
          }
          return redisPub.publish(channel, JSON.stringify({
            qryName: qryName,
            version: version
          }));
        });
      };

      PersonalAssistant.prototype.setQueryUniqifier = function(qryName, uniqifierFn, regex) {
        var opts, _base;
        opts = (_base = this.queryHandlers)[qryName] || (_base[qryName] = {});
        opts.uniqifier = uniqifierFn;
        return opts.regex = regex;
      };

      PersonalAssistant.prototype.setQueryHandler = function(qryName, handlerFn, regex) {
        var opts, _base;
        opts = (_base = this.queryHandlers)[qryName] || (_base[qryName] = {});
        opts.handler = handlerFn;
        return opts.regex = regex;
      };

      PersonalAssistant.prototype.setQueryExtender = function(qryName, extendFn, regex) {
        var opts, _base;
        opts = (_base = this.queryHandlers)[qryName] || (_base[qryName] = {});
        opts.extender = extendFn;
        return opts.regex = regex;
      };

      PersonalAssistant.prototype.use = function(_middleware) {
        return this.middleware.push(_middleware);
      };

      /* Internal utils
      */


      PersonalAssistant.prototype.getHandler = function(handlerName, qryName) {
        var handler, handlers, name, re, _ref;
        handlers = this.queryHandlers[qryName];
        if (handlers) {
          handler = handlers[handlerName];
        }
        if (!handler) {
          _ref = this.queryHandlers;
          for (name in _ref) {
            handlers = _ref[name];
            if (handlers.regex) {
              re = new RegExp(name);
              if (re.test(qryName)) {
                handler = handlers[handlerName];
              }
            }
          }
        }
        return handler;
      };

      PersonalAssistant.prototype.maybeModifiedQueryMsgReceived = function(message) {
        var promise, qryName, version, _ref,
          _this = this;
        _ref = JSON.parse(message), qryName = _ref.qryName, version = _ref.version;
        promise = Q.ninvoke(redisClient, 'smembers', this.qryNameListKeyPref + qryName);
        return promise.then(function(qryIds) {
          var recheckQ;
          recheckQ = async.queue((function(qryId, callback) {
            return _this.recheckQuery(qryId, qryName, version, callback);
          }), maxChunkSize);
          return recheckQ.push(qryIds, function(err) {
            return winston.error(err.stack, err);
          });
        });
      };

      PersonalAssistant.prototype.recheckQuery = function(qryId, qryName, version, callback) {
        var qry;
        qry = {
          version: version,
          qryId: qryId,
          qryName: qryName
        };
        return this.runQuery(qry, function(err, qry) {
          if (err) {
            return callback(err);
          }
          if (qry != null ? qry.modified : void 0) {
            return pusher.trigger("query-" + qry.qryId, 'modified query', qry.result);
          }
        });
      };

      PersonalAssistant.prototype._extendQuery = function(extender, qryId, qry) {
        var promise;
        if (!extender) {
          return Q.fcall(function() {
            throw new Error("No extender for " + qryId);
          });
        }
        promise = Q.ninvoke(redisClient, 'hget', this.qryIdKeyPref + qryId, 'qry');
        promise = promise.then(function(existingQryStr) {
          var existingQry;
          if (!existingQryStr) {
            return Q.fcall(function() {
              throw new Error("No existing query with id: " + qryId);
            });
          }
          existingQry = JSON.parse(existingQryStr);
          return Q.nfcall(extender, existingQry, qry);
        });
        return promise;
      };

      PersonalAssistant.prototype.runQuery = function(qry, callback) {
        var haveOrigQry, qrypromise,
          _this = this;
        haveOrigQry = qry.qry != null;
        qrypromise = Q.fcall(function() {
          var _base;
          if (!qry.qryId) {
            if (qry.uniqifier) {
              qry.qryId = qry.uniqifier(qry);
            } else {
              qry.qryId = typeof (_base = _this.getHandler('uniqifier', qry.qryName)) === "function" ? _base(qry) : void 0;
            }
          }
          if (!qry.qryId) {
            return callback(new Error("Couldnt get a query id"));
          }
        });
        qrypromise = qrypromise.then(function() {
          return Q.ninvoke(redisClient, 'hgetall', _this.qryIdKeyPref + qry.qryId);
        });
        qrypromise = qrypromise.then(function(existing) {
          var existingQry, middleware, mwPromises, promise, _version;
          if (!existing) {
            existing = {};
            if (qry.qryName) {
              redisClient.srem(_this.qryNameListKeyPref + qry.qryName, qry.qryId);
            }
          }
          if (!(qry.qry || existing.qry)) {
            return callback();
          }
          _version = existing.version || null;
          existingQry = existing.result ? JSON.parse(existing.result) : null;
          if (existing.qryName) {
            qry.qryName = existing.qryName;
          }
          if (existing.qry) {
            qry.qry = JSON.parse(existing.qry);
          }
          if (!qry.handler) {
            qry.handler = _this.getHandler('handler', qry.qryName);
          }
          if (!qry.handler) {
            return callback(new Error("Couldn't get a handler for the query with name: " + qry.qryName));
          }
          qry.session = existing.session ? JSON.parse(existing.session) : {};
          mwPromises = [];
          middleware = [];
          middleware.push.apply(middleware, __slice.call(globalMiddleware).concat(__slice.call(_this.middleware)));
          middleware.forEach(function(mw) {
            return mwPromises.push(Q.nfcall(mw, qry));
          });
          promise = Q.all(mwPromises);
          promise = promise.then(function() {
            if ((existingQry != null) && (qry.version && qry.version <= _version)) {
              qrypromise = Q.resolve(existingQry);
            } else {
              qrypromise = Q.nfcall(qry.handler, qry);
            }
            return qrypromise;
          });
          return promise.then(function(qryResult) {
            if (qryResult) {
              qry.result = qryResult;
              if (qry.version != null) {
                promise = Q.resolve(qry.version);
              } else {
                promise = Q.ninvoke(redisClient, 'get', _this.latestQueryVersionKey);
              }
              promise = promise.then(function(_version) {
                var qryData, qryIdKey;
                qry.version = _version;
                qryData = {
                  result: JSON.stringify(qry.result),
                  qryName: qry.qryName,
                  qry: JSON.stringify(qry.qry),
                  version: String(_version),
                  session: JSON.stringify(qry.session)
                };
                qryIdKey = _this.qryIdKeyPref + qry.qryId;
                promise = Q.ninvoke(redisClient, 'hmset', qryIdKey, qryData);
                redisClient.ttl(qryIdKey, function(err, ttl) {
                  if (err) {
                    return winston.error(err.stack, err);
                  }
                  if (ttl === -1 || haveOrigQry) {
                    return redisClient.pexpire(qryIdKey, 2.5 * heartbeatInterval);
                  }
                });
                promise = promise.then(function() {
                  return Q.ninvoke(redisClient, 'sadd', _this.qryNameListKeyPref + qry.qryName, qry.qryId);
                });
                return promise;
              });
            } else {
              promise = Q.resolve();
            }
            return promise.then(function() {
              var modified;
              modified = qryResult !== existingQry;
              qry.modified = modified;
              return callback(null, qry);
            });
          });
        });
        return qrypromise.fail(function(err) {
          winston.error(err.stack);
          return callback(err);
        });
      };

      PersonalAssistant.prototype._keepSocketAlive = function() {
        var getQryFromChannel,
          _this = this;
        getQryFromChannel = function(channelName) {
          return channelName.slice(6);
        };
        return pusher.get({
          path: '/channels'
        }, function(err, req, res) {
          var channelName, channels, qryId, result, val, _results;
          if (err) {
            return winston.warn(err);
          }
          if (res.statusCode === 200) {
            result = JSON.parse(res.body);
            channels = result.channels;
            _results = [];
            for (channelName in channels) {
              val = channels[channelName];
              qryId = getQryFromChannel(channelName);
              _results.push(redisClient.pexpire(_this.qryIdKeyPref + qryId, 1.5 * heartbeatInterval));
            }
            return _results;
          }
        });
      };

      return PersonalAssistant;

    })();
    PAConstructor = function(namespace) {
      if ((namespace != null) && (pas[namespace] != null)) {
        return pas[namespace];
      } else if ((namespace == null) && (rootPa != null)) {
        return rootPa;
      } else {
        return new PersonalAssistant(namespace);
      }
    };
    PAConstructor.use = function(_middleware) {
      return globalMiddleware.push(_middleware);
    };
    return PAConstructor;
  };

  module.exports.PAFactory = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(PAFactory, args, function(){});
  };

}).call(this);
