// Generated by CoffeeScript 1.6.2
(function() {
  var MAX_CHUNK_SIZE, PAFactory, Pusher, Q, async, util, winston, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  async = require('async');

  Q = require('q');

  winston = require('winston');

  Pusher = require('pusher');

  _ = require('underscore');

  util = require('util');

  MAX_CHUNK_SIZE = 50;

  PAFactory = function(options) {
    var PAConstructor, PersonalAssistant, globalMiddleware, handleUpdates, heartbeatInterval, identifier, maxChunkSize, pas, pusher, redisClient, redisPub, redisSub, rootPa;

    globalMiddleware = [];
    pas = {};
    rootPa = null;
    heartbeatInterval = options.heartbeatInterval || 60 * 60 * 1000;
    redisPub = options.redisPub;
    redisSub = options.redisSub;
    redisClient = options.redisClient;
    identifier = options.identifier;
    handleUpdates = options.handleUpdates || false;
    maxChunkSize = options.maxChunkSize || MAX_CHUNK_SIZE;
    pusher = options.pusherClient || new Pusher(options.pusher);
    /**
     * API:
     * 
     * `query`       - Pass in query name and qry data. Return
     *                 the queryId and the result of the query
     * `extendQuery` - Pass in queryId and new query data. Return
     *                 the new queryId, the query result and the new
     *                 extended query
     * `maybeModifiedQuery` - pass in the queryname 
     *                 If anything has changed then we'll get a push out to 
     *                 all listeners that things have changed.
     * `setQueryUniqifier` - setup a handler to basically create the queryId
     *                  from the query.
     * `setQueryHandler` - register the function to handle a specific query name
     * `setQueryExtender` - register the function to handle extending a query
     *
     * `use`         - Add in middleware. Middleware should take the qry parameter
     *                 and a callback
     *
     * `qry` parameter
     *
     * Has the following attributes
     * - session (a session like object that gets stored alongside the query)
     * - qryName
     * - handler
     * - uniqifier
     * - version (optional version to perform the query at. Absent means whatever version)
     * - qryId (may not be present if we don't have one yet)
     * - qry
     * - result (may not be present if we dont have one yet)
     * - modified (has the query been modified this time)
     *
     * Plus middleware etc could add to this.
    */

    PersonalAssistant = (function() {
      function PersonalAssistant(namespace) {
        var channel,
          _this = this;

        if (namespace) {
          pas[namespace] = this;
        } else {
          rootPa = this;
        }
        this.namespace = namespace;
        this.queryHandlers = {};
        this.middleware = [];
        /*
            We set up the following keys in redis
            pa:query:namespace:`qryId`               - the data for the queryId - { result, qryName, qry, version }
            pa:socket:namespace:`socketId`           - a set of queryIds for the given socket
            pa:qryIds:namespace:`qryName`            - a set of queryIds for the given queryname
            pa:latestQueryVersion                    - a key holding the latest query version (to use when
                                                       determining whether a query result should be updated)
        */

        this.qryIdKeyPref = "pa:query:";
        if (namespace) {
          this.qryIdKeyPref += namespace + ":";
        }
        this.socketIdKeyPref = "pa:socket:";
        if (namespace) {
          this.socketIdKeyPref += namespace + ":";
        }
        this.qryNameListKeyPref = "pa:qryIds:";
        if (namespace) {
          this.qryNameListKeyPref += namespace + ":";
        }
        this.latestQueryVersionKey = "pa:latestQueryVersion";
        if (handleUpdates) {
          channel = "maybeModifiedQuery" + (namespace ? ":" + namespace : "");
          redisSub.subscribe(channel);
          redisSub.on("message", function(_channel, message) {
            if (_channel === channel) {
              return _this.maybeModifiedQueryMsgReceived(message);
            }
          });
          setInterval(this._keepSocketAlive.bind(this), heartbeatInterval);
        }
      }

      /* API BITS
      */


      PersonalAssistant.prototype.query = function(qryName, data, initialProps, callback) {
        var externalProps, multiFormat, qry, qryData;

        if (typeof qryName === 'object') {
          callback = initialProps;
          initialProps = data;
          qryData = qryName;
          qryName = void 0;
          data = void 0;
          multiFormat = true;
        } else {
          qryData = {};
          qryData[qryName] = data;
          multiFormat = false;
        }
        if (typeof initialProps === 'function') {
          callback = initialProps;
          initialProps = null;
        }
        initialProps || (initialProps = {});
        qry = {
          qryData: qryData
        };
        externalProps = _.extend({}, initialProps);
        return this.runQuery(qry, externalProps, function(err, result) {
          var qryId, qryIds, res, resultObj;

          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          qryIds = _.keys(result);
          if (qryIds.length === 1 && !multiFormat) {
            qryId = qryIds[0];
            return typeof callback === "function" ? callback(null, qryId, result[qryId].result) : void 0;
          } else {
            resultObj = {};
            for (qryId in result) {
              res = result[qryId];
              resultObj[qryId] = res.result;
            }
            return typeof callback === "function" ? callback(null, resultObj) : void 0;
          }
        });
      };

      PersonalAssistant.prototype.extendQuery = function(qryName, qryId, data, initialProps, callback) {
        var extender, promise,
          _this = this;

        if (typeof initialProps === 'function') {
          callback = initialProps;
          initialProps = null;
        }
        extender = this.getHandler('extender', qryName);
        promise = this._extendQuery(extender, qryId, data);
        promise.then(function(newQry) {
          return _this.query(qryName, newQry, initialProps, callback);
        });
        return promise.fail(function(err) {
          return callback(err);
        });
      };

      PersonalAssistant.prototype.maybeModifiedQuery = function(qryName, socketId, noSelfNotify) {
        var channel,
          _this = this;

        channel = "maybeModifiedQuery" + (this.namespace ? ":" + this.namespace : "");
        return redisClient.incr(this.latestQueryVersionKey, function(err, version) {
          if (err) {
            return winston.log(err);
          }
          if (noSelfNotify) {
            return redisPub.publish(channel, JSON.stringify({
              qryName: qryName,
              version: version,
              socketId: socketId
            }));
          } else {
            redisPub.publish(channel, JSON.stringify({
              qryName: qryName,
              version: version
            }));
            if (socketId) {
              return _this.notifySingleSocket(qryName, socketId, version);
            }
          }
        });
      };

      PersonalAssistant.prototype.setQueryUniqifier = function(qryName, uniqifierFn, regex) {
        var opts, _base;

        opts = (_base = this.queryHandlers)[qryName] || (_base[qryName] = {});
        opts.uniqifier = uniqifierFn;
        return opts.regex = regex;
      };

      PersonalAssistant.prototype.setQueryHandler = function(qryName, handlerFn, regex) {
        var opts, _base;

        opts = (_base = this.queryHandlers)[qryName] || (_base[qryName] = {});
        opts.handler = handlerFn;
        return opts.regex = regex;
      };

      PersonalAssistant.prototype.setQueryExtender = function(qryName, extendFn, regex) {
        var opts, _base;

        opts = (_base = this.queryHandlers)[qryName] || (_base[qryName] = {});
        opts.extender = extendFn;
        return opts.regex = regex;
      };

      PersonalAssistant.prototype.use = function(_middleware) {
        return this.middleware.push(_middleware);
      };

      /* Internal utils
      */


      PersonalAssistant.prototype.getHandler = function(handlerName, qryName) {
        var handler, handlers, name, re, _ref;

        handlers = this.queryHandlers[qryName];
        if (handlers) {
          handler = handlers[handlerName];
        }
        if (!handler) {
          _ref = this.queryHandlers;
          for (name in _ref) {
            handlers = _ref[name];
            if (handlers.regex) {
              re = new RegExp(name);
              if (re.test(qryName)) {
                handler = handlers[handlerName];
              }
            }
          }
        }
        return handler;
      };

      PersonalAssistant.prototype.maybeModifiedQueryMsgReceived = function(message) {
        var promise, qryName, socketId, version, _ref,
          _this = this;

        _ref = JSON.parse(message), qryName = _ref.qryName, version = _ref.version, socketId = _ref.socketId;
        promise = Q.ninvoke(redisClient, 'smembers', this.qryNameListKeyPref + qryName);
        return promise.then(function(qryIds) {
          var recheckQ;

          recheckQ = async.queue((function(qryId, callback) {
            return _this.recheckQuery(qryId, qryName, version, socketId, callback);
          }), maxChunkSize);
          return recheckQ.push(qryIds, function(err) {
            if (err) {
              return winston.error(err.stack, err);
            }
          });
        });
      };

      PersonalAssistant.prototype.recheckQuery = function(qryId, qryName, version, socketId, callback) {
        var qry;

        qry = {
          version: version,
          qryId: qryId,
          qryName: qryName
        };
        return this.runQuery(qry, function(err, resultObj) {
          var channelName, modified, result, resultData;

          if (err) {
            return callback(err);
          }
          for (qryId in resultObj) {
            resultData = resultObj[qryId];
            modified = resultData.modified, result = resultData.result;
            if (modified) {
              channelName = "";
              if (identifier) {
                channelName += identifier + '-';
              }
              channelName += "query-" + qryId;
              pusher.trigger(channelName, 'modified query', result, socketId);
            }
          }
          return callback();
        });
      };

      PersonalAssistant.prototype._extendQuery = function(extender, qryId, qry) {
        var promise;

        if (!extender) {
          return Q.fcall(function() {
            throw new Error("No extender for " + qryId);
          });
        }
        promise = Q.ninvoke(redisClient, 'hget', this.qryIdKeyPref + qryId, 'qry');
        promise = promise.then(function(existingQryStr) {
          var existingQry;

          if (!existingQryStr) {
            return Q.fcall(function() {
              throw new Error("No existing query with id: " + qryId);
            });
          }
          existingQry = JSON.parse(existingQryStr);
          return Q.nfcall(extender, existingQry, qry);
        });
        return promise;
      };

      PersonalAssistant.prototype._getQryIdsForQuery = function(externalProps, qryData) {
        var allIds, handler, qry, qryIdToNameMap, qryIdToQryMap, qryName, _ids;

        qryIdToNameMap = {};
        qryIdToQryMap = {};
        allIds = [];
        for (qryName in qryData) {
          qry = qryData[qryName];
          handler = this.getHandler('uniqifier', qryName);
          if (handler == null) {
            throw new Error("Couldnt find a uniqifier for query name: " + qryName);
          }
          _ids = handler(externalProps, qry);
          if (_ids == null) {
            throw new Error("Couldnt get query id(s)");
          }
          if (Array.isArray(_ids)) {
            if (!(Array.isArray(qry) && _ids.length === qry.length)) {
              throw new Error("The uniqifier has indicated multiple queries but they don't match up with the qry data passed in: " + (utils.inspect(qry)));
            }
            _ids.forEach(function(id, index) {
              qryIdToQryMap[id] = qry[index];
              qryIdToNameMap[id] = qryName;
              return allIds.push(id);
            });
          } else {
            qryIdToNameMap[_ids] = qryName;
            qryIdToQryMap[_ids] = qry;
            allIds.push(_ids);
          }
        }
        return {
          qryIdToNameMap: qryIdToNameMap,
          qryIdToQryMap: qryIdToQryMap,
          qryIdToResultMap: {},
          qryIdToExistingResultMap: {},
          allIds: allIds
        };
      };

      PersonalAssistant.prototype._getHandlersForQryIds = function(qryIdData) {
        var handler, handlerId, handlerQryIdMap, id, ids, knownHandlers, qryIds, qryName, _i, _len;

        knownHandlers = [];
        handlerQryIdMap = [];
        for (qryName in qryIdData) {
          qryIds = qryIdData[qryName];
          handler = this.getHandler('handler', qryName);
          if (!handler) {
            throw new Error("Can't get handler for query name: " + qryName);
          }
          handlerId = knownHandlers.indexOf(handler);
          if (handlerId !== -1) {
            ids = handlerQryIdMap[handlerId];
            for (_i = 0, _len = qryIds.length; _i < _len; _i++) {
              id = qryIds[_i];
              if (__indexOf.call(ids, id) < 0) {
                ids.push(id);
              }
            }
          } else {
            knownHandlers.push(handler);
            handlerId = knownHandlers.indexOf(handler);
            handlerQryIdMap[handlerId] = qryIds.slice(0);
          }
        }
        return {
          handlers: knownHandlers,
          qryIdsMap: handlerQryIdMap
        };
      };

      PersonalAssistant.prototype._initializeQueryProps = function(qry, externalProps) {
        if (qry.qryData) {
          qry.qryIdData = this._getQryIdsForQuery(externalProps, qry.qryData);
        } else {
          if (qry.qryId == null) {
            throw new Error("Not enough data to construct query - " + (util.inspect(qry)));
          }
          qry.qryIdData = {
            qryIdToNameMap: {},
            qryIdToQryMap: {},
            qryIdToResultMap: {},
            qryIdToExistingResultMap: {},
            allIds: [qry.qryId]
          };
          if (qry.qryName != null) {
            qry.qryIdData.qryIdToNameMap[qry.qryId] = [qry.qryName];
          }
        }
      };

      PersonalAssistant.prototype._findExistingQueries = function(qryIds) {
        var promises, qryId, _i, _len;

        promises = [];
        for (_i = 0, _len = qryIds.length; _i < _len; _i++) {
          qryId = qryIds[_i];
          promises.push(Q.ninvoke(redisClient, 'hgetall', this.qryIdKeyPref + qryId));
        }
        return Q.all(promises);
      };

      PersonalAssistant.prototype._removeQryIdFromData = function(data, qryId) {
        delete data.qryIdToNameMap[qryId];
        delete data.qryIdToQryMap[qryId];
        delete data.qryIdToResultMap[qryId];
        delete data.qryIdToExistingResultMap[qryId];
        data.allIds = _.without(data.allIds, qryId);
      };

      PersonalAssistant.prototype._buildAndCheckQueryFromExisting = function(qryIdData, existingObjs, version) {
        var existingQueries,
          _this = this;

        existingQueries = [];
        existingObjs.forEach(function(existing, index) {
          var existingQry, existingResult, qryId, qryName, _version;

          qryId = qryIdData.allIds[index];
          qryName = qryIdData.qryIdToNameMap[qryId];
          if (!existing) {
            existing = {};
            if (qryName) {
              redisClient.srem(_this.qryNameListKeyPref + qryName, qryId);
            }
          }
          if (!(qryIdData.qryIdToQryMap[qryId] || existing.qry)) {
            _this._removeQryIdFromData(qryIdData, qryId);
            return;
          }
          _version = existing.version || null;
          existingResult = existing.result ? JSON.parse(existing.result) : null;
          qryIdData.qryIdToExistingResultMap[qryId] = existingResult;
          if ((version != null) && (_version != null) && version <= _version) {
            qryIdData.qryIdToResultMap[qryId] = existingResult;
          }
          if (qryName && existing.qryName) {
            if (String(qryName) !== String(existing.qryName)) {
              throw new Error("Query names don't match for qryId: " + qryId + ". Expected " + qryName + " but got " + existing.qryName);
            }
          } else if (existing.qryName) {
            qryName = existing.qryName;
            qryIdData.qryIdToNameMap[qryId] = qryName;
          }
          if (!qryName) {
            throw new Error("Have no query name for qryId: " + qryId);
          }
          existingQry = existing.qry ? JSON.parse(existing.qry) : null;
          if ((existingQry != null) && (qryIdData.qryIdToQryMap[qryId] == null)) {
            qryIdData.qryIdToQryMap[qryId] = existingQry;
          } else if ((existingQry != null) && (qryIdData.qryIdToQryMap[qryId] != null)) {
            if (existing.qry !== JSON.stringify(qryIdData.qryIdToQryMap[qryId])) {
              throw new Error("Got two separate queries for qryId: " + qryId + "\nExisting: " + (utils.inspect(existingQry)) + "\nOriginal: " + (utils.inspect(qryIdData.qryIdToQryMap[qryId])));
            }
          }
        });
      };

      PersonalAssistant.prototype._setQuerySession = function(ids, externalProps, existingObjs) {
        var _ref;

        if (ids.length === 1) {
          return externalProps.session = ((_ref = existingObjs[0]) != null ? _ref.session : void 0) ? JSON.parse(existingObjs[0].session) : {};
        } else {
          return externalProps.session = {};
        }
      };

      PersonalAssistant.prototype._runMiddleware = function(externalProps, qryData) {
        var middleware, mwPromises;

        mwPromises = [];
        middleware = [];
        middleware.push.apply(middleware, __slice.call(globalMiddleware).concat(__slice.call(this.middleware)));
        middleware.forEach(function(mw) {
          return mwPromises.push(Q.nfcall(mw, externalProps, qryData));
        });
        return Q.all(mwPromises);
      };

      PersonalAssistant.prototype._handleOutstandingResultResponse = function(qryIds, resultObj) {
        return function(results) {
          if (!Array.isArray(qryIds)) {
            results = [results];
            qryIds = [qryIds];
          }
          results.forEach(function(result, index) {
            return resultObj[qryIds[index]] = result;
          });
          return Q.resolve();
        };
      };

      PersonalAssistant.prototype._fetchOutstandingResults = function(externalProps, qryIdData) {
        var data, handlerData, outstandingQueries, promise, promises, qryId, qryName, _i, _len,
          _this = this;

        outstandingQueries = _.reject(qryIdData.allIds, function(qryId) {
          return qryIdData.qryIdToResultMap[qryId] != null;
        });
        if (outstandingQueries.length > 0) {
          data = {};
          for (_i = 0, _len = outstandingQueries.length; _i < _len; _i++) {
            qryId = outstandingQueries[_i];
            qryName = qryIdData.qryIdToNameMap[qryId];
            data[qryName] || (data[qryName] = []);
            data[qryName].push(qryId);
          }
          handlerData = this._getHandlersForQryIds(data);
          promises = [];
          handlerData.handlers.forEach(function(handler, index) {
            var qryIds, queries, _j, _len1, _prom;

            qryIds = handlerData.qryIdsMap[index];
            if (qryIds.length === 1) {
              qryId = qryIds[0];
              _prom = Q.nfcall(handler, externalProps, qryIdData.qryIdToQryMap[qryId]);
              _prom = _prom.then(_this._handleOutstandingResultResponse(qryId, qryIdData.qryIdToResultMap));
              return promises.push(_prom);
            } else if (qryIds.length > 1) {
              queries = [];
              for (_j = 0, _len1 = qryIds.length; _j < _len1; _j++) {
                qryId = qryIds[_j];
                queries.push(qryIdData.qryIdToQryMap[qryId]);
              }
              _prom = Q.nfcall(handler, externalProps, queries);
              _prom = _prom.then(_this._handleOutstandingResultResponse(qryIds, qryIdData.qryIdToResultMap));
              return promises.push(_prom);
            }
          });
          promise = Q.all(promises);
        } else {
          promise = Q.resolve();
        }
        return promise;
      };

      PersonalAssistant.prototype._storeResults = function(qryIdData, version, session, socketId, haveOrigQry) {
        var promises,
          _this = this;

        promises = [];
        _.each(qryIdData.qryIdToResultMap, function(qryResult, qryId) {
          var promise, qryName;

          qryName = qryIdData.qryIdToNameMap[qryId];
          if (version != null) {
            promise = Q.resolve(version);
          } else {
            promise = Q.ninvoke(redisClient, 'get', _this.latestQueryVersionKey);
          }
          promise = promise.then(function(_version) {
            var qryData, qryIdKey;

            qryData = {
              result: JSON.stringify(qryResult),
              qryName: qryName,
              qry: JSON.stringify(qryIdData.qryIdToQryMap[qryId]),
              version: String(_version),
              session: JSON.stringify(session)
            };
            qryIdKey = _this.qryIdKeyPref + qryId;
            promise = Q.ninvoke(redisClient, 'hmset', qryIdKey, qryData);
            redisClient.ttl(qryIdKey, function(err, ttl) {
              if (err) {
                return winston.error(err.stack, err);
              }
              if (ttl === -1 || haveOrigQry) {
                return redisClient.pexpire(qryIdKey, 2.5 * heartbeatInterval);
              }
            });
            promise = promise.then(function() {
              var promiseA, promiseB, sockData, socketIdKey;

              promiseA = Q.ninvoke(redisClient, 'sadd', _this.qryNameListKeyPref + qryName, qryId);
              if (socketId) {
                socketIdKey = _this.socketIdKeyPref + socketId;
                sockData = JSON.stringify({
                  qryId: qryId,
                  qryName: qryName
                });
                promiseB = Q.ninvoke(redisClient, 'sadd', socketIdKey, sockData);
                redisClient.ttl(socketIdKey, function(err, ttl) {
                  if (err) {
                    return winston.error(err.stack, err);
                  }
                  if (ttl === -1) {
                    redisClient.pexpire(socketIdKey, 2.5 * heartbeatInterval);
                  }
                });
              } else {
                promiseB = Q.resolve();
              }
              return Q.all([promiseA, promiseB]);
            });
            return promise;
          });
          return promises.push(promise);
        });
        return Q.all(promises);
      };

      PersonalAssistant.prototype._createResultObject = function(results, existingResults) {
        var existing, modified, qryId, result, resultObj;

        resultObj = {};
        for (qryId in results) {
          result = results[qryId];
          existing = existingResults[qryId];
          modified = JSON.stringify(result) !== JSON.stringify(existing);
          resultObj[qryId] = {
            result: result,
            modified: modified
          };
        }
        return resultObj;
      };

      PersonalAssistant.prototype.runQuery = function(qry, externalProps, callback) {
        var qrypromise,
          _this = this;

        if (callback == null) {
          callback = externalProps;
          externalProps = {};
        }
        this._initializeQueryProps(qry, externalProps);
        qrypromise = this._findExistingQueries(qry.qryIdData.allIds);
        qrypromise = qrypromise.then(function(existingObjs) {
          var mwpromise, promise;

          _this._buildAndCheckQueryFromExisting(qry.qryIdData, existingObjs, qry.version);
          _this._setQuerySession(qry.qryIdData.allIds, externalProps, existingObjs);
          mwpromise = _this._runMiddleware(externalProps, qry.qryData);
          promise = mwpromise.then(function() {
            return _this._fetchOutstandingResults(externalProps, qry.qryIdData);
          });
          return promise.then(function(qryResults) {
            var haveOrigQry;

            haveOrigQry = qry.qryData != null;
            promise = _this._storeResults(qry.qryIdData, qry.version, externalProps.session, externalProps.socketId, haveOrigQry);
            return promise.then(function() {
              var resultObj;

              resultObj = _this._createResultObject(qry.qryIdData.qryIdToResultMap, qry.qryIdData.qryIdToExistingResultMap);
              return callback(null, resultObj);
            });
          });
        });
        return qrypromise.fail(function(err) {
          winston.error(err.stack);
          return callback(err);
        });
      };

      PersonalAssistant.prototype.notifySingleSocket = function(qryName, socketId, version) {
        var promise,
          _this = this;

        promise = Q.ninvoke(redisClient, 'smembers', this.socketIdKeyPref + socketId);
        promise = promise.then(function(qryObjStrs) {
          var cb, obj, qryObjs, _i, _len, _results;

          qryObjs = _.map(qryObjStrs, function(str) {
            return JSON.parse(str);
          });
          cb = function(err) {
            if (err) {
              winston.error(err.stack, err);
            }
          };
          _results = [];
          for (_i = 0, _len = qryObjs.length; _i < _len; _i++) {
            obj = qryObjs[_i];
            if (obj.qryName === qryName) {
              _results.push(_this.recheckQuery(obj.qryId, qryName, version, void 0, cb));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
        return promise;
      };

      PersonalAssistant.prototype._keepSocketAlive = function() {
        var channelOffset, getQryFromChannel, getSocketFromChannel, qryOffset, socketOffset,
          _this = this;

        channelOffset = identifier.length;
        qryOffset = channelOffset + 7;
        socketOffset = channelOffset + 8;
        getQryFromChannel = function(channelName) {
          return channelName.slice(qryOffset);
        };
        getSocketFromChannel = function(channelName) {
          return channelName.slice(socketOffset);
        };
        pusher.get({
          path: '/channels',
          params: {
            filter_by_prefix: "" + identifier + "-query-"
          }
        }, function(err, req, res) {
          var channelName, channels, qryId, result, val, _results;

          if (err) {
            return winston.warn(err);
          }
          if (res.statusCode === 200) {
            result = JSON.parse(res.body);
            channels = result.channels;
            _results = [];
            for (channelName in channels) {
              val = channels[channelName];
              qryId = getQryFromChannel(channelName);
              _results.push(redisClient.pexpire(_this.qryIdKeyPref + qryId, 1.5 * heartbeatInterval));
            }
            return _results;
          }
        });
        return pusher.get({
          path: '/channels',
          params: {
            filter_by_prefix: "" + identifier + "-socket-"
          }
        }, function(err, req, res) {
          var channelName, channels, result, sockId, val, _results;

          if (err) {
            return winston.warn(err);
          }
          if (res.statusCode === 200) {
            result = JSON.parse(res.body);
            channels = result.channels;
            _results = [];
            for (channelName in channels) {
              val = channels[channelName];
              sockId = getSocketFromChannel(channelName);
              _results.push(redisClient.pexpire(_this.sockIdKeyPref + sockId, 1.5 * heartbeatInterval));
            }
            return _results;
          }
        });
      };

      return PersonalAssistant;

    })();
    PAConstructor = function(namespace) {
      if ((namespace != null) && (pas[namespace] != null)) {
        return pas[namespace];
      } else if ((namespace == null) && (rootPa != null)) {
        return rootPa;
      } else {
        return new PersonalAssistant(namespace);
      }
    };
    PAConstructor.use = function(_middleware) {
      return globalMiddleware.push(_middleware);
    };
    return PAConstructor;
  };

  module.exports.PAFactory = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(PAFactory, args, function(){});
  };

}).call(this);
